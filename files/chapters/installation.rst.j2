Installation Manual
===================

Create a CSR for the issuing CA
-------------------------------

#. Log in to {{ servers.issuing_ca.name }} using RDP.

#. Optionally adjust the keyboard layout using PowerShell::

    Set-WinUserLanguageList -LanguageList sv-SE, en-US -Force

#. Reset the password of the domain administrator account using PowerShell::

    $NewPassword = Read-Host -AsSecureString
    Set-ADAccountPassword -Identity {{ accounts.domain.user }} -NewPassword $NewPassword -Reset

#. Create the file ``%systemroot%\CAPolicy.inf``::

    [Version]
    Signature = "$Windows NT$"

    [Certsrv_Server]
    LoadDefaultTemplates = 0

#. Install the AD CS Windows feature::

    Install-WindowsFeature Adcs-Cert-Authority -IncludeManagementTools

#. Create an issuing CA using PowerShell::

{% if servers.issuing_ca.policy.key_specification == 'P256' %}
    Install-AdcsCertificationAuthority -CAType EnterpriseSubordinateCa -CryptoProviderName "ECDSA_P256#{{ servers.issuing_ca.policy.key_storage_provider }}" -KeyLength 256 -HashAlgorithmName SHA256 -CACommonName "ICA1" -CADistinguishedNameSuffix "O={{ customer.name }},C={{ customer.country }}" -OutputCertRequestFile "C:\ICA1.csr" -LogDirectory "{{ servers.issuing_ca.location.log }}" -DatabaseDirectory "{{ servers.issuing_ca.location.database }}" -Force
{% elif servers.issuing_ca.policy.key_specification == 'RSA4096' %}
    Install-AdcsCertificationAuthority -CAType EnterpriseSubordinateCa -CryptoProviderName "RSA#{{ servers.issuing_ca.policy.key_storage_provider }}" -KeyLength 4096 -HashAlgorithmName SHA256 -CACommonName "ICA1" -CADistinguishedNameSuffix "O={{ customer.name }},C={{ customer.country }}" -OutputCertRequestFile "C:\ICA1.csr" -LogDirectory "{{ servers.issuing_ca.location.log }}" -DatabaseDirectory "{{ servers.issuing_ca.location.database }}" -Force
{% else %}
    Unknown key specification '{{ servers.issuing_ca.policy.key_specification }}'.
{% endif %}

#. Transfer the file ``C:\ICA1.csr`` to {{ servers.root_ca.name }}.

Create repositories
-------------------

{% for server in servers.repositories %}
Create {{ server.name }}
~~~~~~~{{ '~' * server.name | length }}

#. Log in to {{ server.name }} using RDP.

#. Optionally adjust the keyboard layout using PowerShell::

    Set-WinUserLanguageList -LanguageList sv-SE, en-US -Force

#. Reset the password of the local administrator account using PowerShell::

    $NewPassword = Read-Host -AsSecureString
    $UserAccount = Get-LocalUser -Name "{{ accounts.local.user }}"
    $UserAccount | Set-LocalUser -Password $NewPassword

#. Install IIS and remove the default website using PowerShell::

    Install-WindowsFeature -Name Web-Server -IncludeManagementTools
    Remove-IISSite -Name "Default Web Site"

#. Create a folder where the repository files should be stored::

    New-Item -Path "C:\inetpub" -Name "pki" -ItemType "directory"

#. Create a new website for the repository::

    New-IISSite -Name PKI -PhysicalPath "C:\inetpub\pki" -Protocol http -BindingInformation "*:80:"

#. Create a local user account::

    $Password = ConvertTo-SecureString "{{ secret }}" -AsPlaintext -Force
    New-LocalUser -AccountNeverExpires -Name "PKIUser" -Password $Password

#. Create an SMB share using PowerShell::

    New-SmbShare -Name "PKI Repository" -Path "C:\inetpub\pki"

#. Grant NTFS and SMB share permissions::

    $Acl = Get-ACL "C:\inetpub\pki\"
    $AccessRule = New-Object System.Security.AccessControl.FileSystemAccessRule("Everyone", "FullControl", "ContainerInherit,Objectinherit", "None", "Allow")
    $Acl.AddAccessRule($AccessRule)
    Set-ACL "C:\inetpub\pki\" $Acl
    Grant-SmbShareAccess -Name "PKI Repository" -AccountName "{{ server.name ~ '.' ~ customer.domain }}\PKIUser" -AccessRight Full -Force
{% endfor %}

Create the root CA
-------------------

#. Log in to {{ servers.root_ca.name }} using RDP.

#. Optionally adjust the keyboard layout using PowerShell::

    Set-WinUserLanguageList -LanguageList sv-SE, en-US -Force

#. Check the local time against a reliable watch, and adjust it if necessary.

#. Reset the password of the local administrator account using PowerShell::

    $NewPassword = Read-Host -AsSecureString
    $UserAccount = Get-LocalUser -Name "{{ accounts.local.user }}"
    $UserAccount | Set-LocalUser -Password $NewPassword

#. Install the AD CS Windows feature::

    Install-WindowsFeature Adcs-Cert-Authority -IncludeManagementTools

{% if servers.root_ca.location.existing_backup is defined %}
#. Restore the CA certificate and private key::

    $BackupPassword = Read-Host -AsSecureString
    Install-AdcsCertificationAuthority -CAType StandaloneRootCa -CertFile '{{ servers.root_ca.location.existing_backup }}' -CertFilePassword $BackupPassword -DatabaseDirectory $(Join-Path $env:SystemRoot "System32\CertLog") -Force

#. Restore the CA database using CertUtil::

    Remove-Item C:\Windows\System32\CertLog\* -Force
    CertUtil -restoreDB {{ servers.root_ca.location.existing_backup }}

#. Import the registry keys::

    reg import {{ servers.root_ca.location.existing_backup }}\backup.reg

#. Restart AD CS::

    net stop certsvc
    net start certsvc

{% else %}
#. Create a root CA using PowerShell::

{% if servers.root_ca.policy.key_specification == 'P256' %}
    Install-AdcsCertificationAuthority -CAType StandaloneRootCa -CryptoProviderName "ECDSA_P256#{{ servers.root_ca.policy.key_storage_provider }}" -KeyLength 256 -HashAlgorithmName SHA256 -ValidityPeriod Years -ValidityPeriodUnits 25 -CACommonName "R1" -CADistinguishedNameSuffix "O={{ customer.name }},C={{ customer.country }}" -DatabaseDirectory $(Join-Path $env:SystemRoot "System32\CertLog") -Force
{% elif servers.root_ca.policy.key_specification == 'RSA4096' %}
    Install-AdcsCertificationAuthority -CAType StandaloneRootCa -CryptoProviderName "RSA#{{ servers.root_ca.policy.key_storage_provider }}" -KeyLength 4096 -HashAlgorithmName SHA256 -ValidityPeriod Years -ValidityPeriodUnits 25 -CACommonName "R1" -CADistinguishedNameSuffix "O={{ customer.name }},C={{ customer.country }}" -DatabaseDirectory $(Join-Path $env:SystemRoot "System32\CertLog") -Force
{% else %}
    Unknown key specification '{{ servers.root_ca.policy.key_specification }}'.
{% endif %}

#. Create and run the file ``C:\CASetup.bat``::

    CertUtil -setreg CA\CRLPeriodUnits 52
    CertUtil -setreg CA\CRLPeriod Weeks
    CertUtil -setreg CA\CRLDeltaPeriodUnits 0
    CertUtil -setreg CA\CRLDeltaPeriod Days

    :: https://www.pkisolutions.com/adcs-certificate-serial-number-generation-algorithms-a-comrehensive-guide
    CertUtil -setreg ca\highserial {{ servers.root_ca.policy.high_serial | default(0) }}
{% if servers.root_ca.policy.keep_expired_certificates_on_crl | default(false) %}
    CertUtil –setreg ca\CRLFlags +CRLF_PUBLISH_EXPIRED_CERT_CR
{% endif %}

    :: https://docs.microsoft.com/en-us/previous-versions/windows/it-pro/windows-server-2012-r2-and-2012/hh831574(v=ws.11)#configure-the-ca
    CertUtil -setreg CA\CRLPublicationURLs "1:C:\%%3.crl\n2:http://pki.{{ customer.domain }}/%%3.crl"
    CertUtil -setreg CA\CACertPublicationURLs "3:http://pki.{{ customer.domain }}/%%3.crt"

    CertUtil -setreg CA\ValidityPeriodUnits 10
    CertUtil -setreg CA\ValidityPeriod Years

    CertUtil -setreg CA\AuditFilter 127

    net stop certsvc
    net start certsvc
    CertUtil -ping 30
{% endif %}

Sign the issuing CA
-------------------

#. Submit the CSR for the issuing CA and save the request ID::

    $request = CertReq -submit -config - C:\ICA1.csr | Out-String | Select-String 'RequestId: (\d+)'
    $requestId = $request.Matches[0].Groups[1].Value.Trim()

#. Accept the request and retrieve a copy of the issuing CA certificate::

    CertUtil -resubmit $requestId
    CertReq -retrieve -config - $requestId C:\ICA1.crt

#. Issue a CRL from the root CA::

    CertUtil -crl

#. Export a copy of the root CA certificate::

    CertUtil "-ca.cert" "C:\R1.crt"

{% for server in servers.repositories %}
#. Transfer the files ``C:\ICA1.crt``, ``C:\R1.crt`` and ``C:\R1.crl`` to ``C:\inetpub\pki`` on {{ server.name }}.
{% endfor %}

#. Transfer the file ``C:\ICA1.crt`` and ``C:\R1.crt`` to {{ servers.issuing_ca.name }}.

Activate the issuing CA
-----------------------

#. Log in to {{ servers.issuing_ca.name }} using RDP.

#. Publish the root CA certificate to AD::

    CertUtil -dspublish -f C:\R1.crt

#. Install the CA certificate chain::

    Import-Certificate -FilePath C:\R1.crt -CertStoreLocation Cert:\LocalMachine\Root
    CertUtil -installcert "C:\ICA1.crt"

#. Create and run the file ``C:\CASetup.bat``::

    CertUtil -setreg CA\CRLPeriodUnits 7
    CertUtil -setreg CA\CRLPeriod Days
    CertUtil -setreg CA\CRLDeltaPeriodUnits 0
    CertUtil -setreg CA\CRLDeltaPeriod Days

    :: https://docs.microsoft.com/en-us/previous-versions/windows/it-pro/windows-server-2012-r2-and-2012/hh831574(v=ws.11)#configure-the-ca
    CertUtil -setreg CA\CRLPublicationURLs "1:C:\%%3.crl\n2:http://pki.{{ customer.domain }}/%%3-%%8.crl"
    CertUtil -setreg CA\CACertPublicationURLs "3:http://pki.{{ customer.domain }}/%%4.crt"

    CertUtil -setreg CA\ValidityPeriodUnits 2
    CertUtil -setreg CA\ValidityPeriod Years

    CertUtil -setreg CA\AuditFilter 127

    net stop certsvc
    net start certsvc
    CertUtil -ping 30

{% if smtp_exit_module is defined and servers.issuing_ca.smtp_exit_module %}
Install the SMTP exit module
----------------------------

#. Create and run the file ``C:\ConfigureSMTPExitModule.bat``.

    .. literalinclude:: ../scripts/smtp_exit_module.bat
       :language: batch
       :linenos:

{% endif %}

{% if servers.issuing_ca.web_enrollment %}
Configure web enrollment
------------------------

#. Run the following commands in PowerShell to enable web enrollment::

    Add-WindowsFeature Adcs-Web-Enrollment
    Install-AdcsWebEnrollment

#. IIS uses the built-in *WebServer* template to fetch certificates, and it must be temporarily enabled on the CA.

    Add-CATemplate -Name WebServer -Force

#. Click on the Start button, type ``inetmgr`` and press **Enter** to start *Internet Information Services (IIS) Manager*.

#. Expand ``{{ servers.issuing_ca.name }}`` in the tree on the left.

#. Double-click on **Server Certificates**.

#. In the *Actions* pane on the right, click on **Create Domain Certificate...**.

#. Fill in the subject DN attributes using the table below.

.. list-table::
   :widths: 1 1
   :header-rows: 0

   * - **Common name**
     - ``{{ servers.issuing_ca.name.lower() }} ~ {{ customer.domain }}``
   * - **Organisation**
     - ``{{ customer.name }}``
   * - **Organizational unit**
     - ``IT``
   * - **City/locality**
     - ``{{ customer.city }}``
   * - **State/province**
     - ``{{ customer.state }}``
   * - **Country/region**
     - ``{{ customer.country }}``

#. Click on **Next**.

#. Click on **Select...**, select the certificate authority **ICA1** in the list and click on **OK**.

#. In the *Friendly name** field, type ``{{ servers.issuing_ca.name.lower() }} ~ {{ customer.domain }}`` and click on **Finish** to issue the web server certificate.

#. Run the following PowerShell command to disable the *WebServer* template on the CA::

    Remove-CATemplate -Name WebServer -Force

#. Expand **Sites** in the tree on the left, right-click on **Default Web Site** and click **Edit Bindings...**.

#. Click on **Add...** to add a new binding, and make the following adjustments:

    #. In the *Type* dropdown, pick **https**.

    #. In the *Host name* field, type ``{{ servers.issuing_ca.name.lower() }} ~ {{ customer.domain }}``.

    #. In the *SSL certificate* dropdown, select **{{ servers.issuing_ca.name.lower() }} ~ {{ customer.domain }}**.

#. Click on **OK** to add the new binding.

#. Click on **Close** to close the *Site Bindings* dialog window.

#. Expand **Default Web Site** in the tree on the left, and click on **CertSrv**.

#. Click on **SSL Settings**.

#. Tick the checkbox **Require SSL** and click on **Apply** in the pane on the right.
{% endif %}

Publish a CRL from the issuing CA to the repository
---------------------------------------------------

#. Create the file ``C:\CopyCRL.bat``::

{% for server in servers.repositories %}
    :: Copy CRLs to {{ server.name }}
    net use X: "\\{{ server.name }}.{{ customer.domain }}\PKI Repository" "{{ secret }}" /user:{{ server.name }}.{{ customer.domain }}\PKIUser /persistent:Yes
    xcopy "C:\*.crl" X:\ /y
    net use X: /delete
{% endfor %}

#. Schedule a daily background task::

    $actions = New-ScheduledTaskAction -Execute "C:\CopyCRL.bat"
    $trigger = New-ScheduledTaskTrigger -Daily -At "02:00"
    $principal = New-ScheduledTaskPrincipal -UserId "SYSTEM"
    $settings = New-ScheduledTaskSettingsSet -RunOnlyIfNetworkAvailable -WakeToRun
    $task = New-ScheduledTask -Action $actions -Principal $principal -Trigger $trigger -Settings $settings
    Register-ScheduledTask "CopyCRL" -InputObject $task

#. Issue a CRL and run the task to copy it to the repository::

    CertUtil -crl
    Start-ScheduledTask -TaskName "CopyCRL"

Configure certificate templates
-------------------------------

#. Log in to one of the domain controllers using RDP.

    .. note:: You can use the command ``nltest /dclist:{{ customer.domain }}`` to get the names of the domain controllers.

#. Click on the start button, type ``mmc.exe`` and press **Enter** to open Microsoft Management Console.

#. Press **Ctrl + M**, double-click on the **Certificate Templates** snap-in and click on **OK**.

#. Double-click on **Certificate Templates** in the tree on the left. This will show all available certificate templates in a list on the right.

{% for template in templates %}
#. Right-click on **{{ template.from }}** and click on **Duplicate Template** in the context menu.

#. Click on the **Compatibility** tab and make the following changes:

    #. In the *Certification Authority* dropdown, pick **Windows Server 2016** and click on **OK**.

    #. In the *Certificate recipients* dropdown, pick **Windows 10 / Windows Server 2016** and click on **OK**.

#. Click on the **General** tab and make the following changes:

    #. In the **Template display name** field, type ``{{ template.name }}``.

    #. In the **Validity period** field, specify ``{{ template.validity }}`` days.

    #. In the **Renewal period** field, specify ``{{ template.renewal_period }}`` days.

{% if template.publish %}
    #. Tick the options **Publish certificate in Active Directory** and **Do not automatically reenroll if a duplicate certificate exists in Active Directory**.
{% endif %}

#. Click on the **Cryptography** tab and make the following changes:

    #. In the **Provider Category** dropdown, pick **Key Storage Provider**.

{% if template.use_ec %}
    #. In the **Algorithm name** dropdown, pick **ECDH_P256**.
{% endif %}

    #. In the **Request Hash** dropdown, pick **SHA256**.

#. Click on the  **Request Handling** tab and make the following changes:

    #. Untick the option **Allow private key to be exported**.

#. Click on the **Security** tab and make the following changes:

{% for group in template.groups %}
    #. Click on **Add...**, type ``{{ group.name }}`` and click on **OK**.
{% if group.autoenroll %}
    #. Tick the options **Read**, **Enroll** and **Autoenroll**.
{% else %}
    #. Tick the options **Read** and **Enroll**.
{% endif %}
{% endfor %}

#. Click on the **Subject Name** tab and make the following changes:

{% if template.subject.email %}
    #. Tick the option **E-mail name**.
{% endif %}

{% if template.subject.dnsname %}
    #. Tick the option **DNS name**.
{% endif %}

{% if template.subject.upn %}
    #. Tick the option **UPN**.
{% endif %}

#. Click on **OK** to save the template.
{% endfor %}

Enable autoenrollment
---------------------

#. Click on the start button, type **Group Policy Management** and press **Enter**.

#. Right-click on **Domains → {{ customer.domain }} → Group Policy Objects → Default Domain Policy** and click on **Edit** to open *Group Policy Management Editor*.

#. Expand **Computer Configuration → Policies → Windows Settings → Security Settings** and click on **Public Key Policies**. The public key policies is shown on the right. Double-click on **Certificate Services Client - Auto-enrollment** to open *Certificate Services Client - Auto-enrollment Properties*.

#. In the **Configuration Model** dropdown, pick **Enabled**.

#. Tick the option **Renew expired certificates, update pending certificates, and remove revoked certificates**.

#. Tick the option **Update certificates that use certificate templates**.

#. Click on **OK**.

#. Expand **User Configuration → Policies → Windows Settings → Security Settings** and click on **Public Key Policies**. The public key policies is shown on the right. Double-click on **Certificate Services Client - Auto-enrollment** to open *Certificate Services Client - Auto-enrollment Properties*.

#. In the **Configuration Model** dropdown, pick **Enabled**.

#. Tick the option **Renew expired certificates, update pending certificates, and remove revoked certificates**.

#. Tick the option **Update certificates that use certificate templates**.

#. Tick the option **Display user notifications for expiring certificates in user and machine MY store**.

#. Click on **OK**.

Enable certificate templates
----------------------------

#. Log in to ``{{ servers.issuing_ca.name }}`` using RDP.

#. Pull the GPO changes from the domain controller::

    gpupdate

{% for template in templates %}
#. Enable the template *{{ template.name }}* using PowerShell::

    Add-CATemplate -Name "{{ template.name | replace(' ', '') }}" -Force

{% endfor %}

{% if servers.issuing_ca.dcom_port is defined %}
Set a static DCOM port
----------------------

#. Click on the start button, type ``Component Services`` and press **Enter**.

#. In the tree on the left, expand **Component Services → Computers → My Computer** and click on **DCOM Config**.

#. In the panel on the right, right-click on **CertSrv Request** on click on **Properties**.

#. Click on the **Endpoints** tab.

#. Click on **Add**. The *DCOM Enpoint Properties* dialog is shown.

#. Select the option **Use static endpoint** and type in the port number ``{{ servers.issuing_ca.dcom_port }}`` in the textbox, then click on **OK**.

#. Click on **OK** to close the *CertSrv Request Properties* dialog.

.. figure:: ../graphics/dcom_configuration.png

        DCOM configuration for *CertSrv Request* with a static endpoint for port 4000.

#. Disable RPC for the *ICertPassage* interface::

    certutil -setreg ca\interfaceflags +IF_NORPCICERTREQUEST

#. Restart AD CS::

    net stop certsvc
    net start certsvc

.. note:: The CA will not change listening ports until the first certificate request comes in. This means that you must send a certificate request to the CA before making adjustments to the firewall rules.

    Check which port is being used by running something like:

    .. code-block:: powershell

        netstat -anob | Select-String -Pattern certsrv.exe -Context 1,0

{% endif %}
